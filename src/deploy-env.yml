parameters:
  AcrContainerAppId: ''
  AzureFeedName: ''
  AzureLocation: ''
  ContainerAppName: ''
  ContainerAppUrl: ''
  ContainerRegistryPassword: ''
  containerAppEnvironmentName: ''
  ContainerImage: ''
  DatabaseAction: ''
  DatabaseName: ''
  DatabasePassword: ''
  DatabaseUser: ''
  DatabasePerformanceLevel: ''
  deployAmazon: ''
  deployApple: ''
  deployGoogle: ''
  environmentName: ''
  HttpPort: ''
  passwordSecretRef: ''
  ResourceGroupName: ''
  RegistryLoginServer: ''





steps:

- task: PowerShell@2
  displayName: 'check for empty parameters'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "pwsr:  " ${{ parameters.passwordSecretRef }}
      Write-Host "Http Port:  "${{ parameters.HttpPort}}
      
- task: AzureCLI@2
  displayName: 'Query and store subscription id for unique resource name'
  inputs:
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: |
      SUBSCRIPTION_ID=$(az account show --query id --output tsv)
      echo "##vso[task.setvariable variable=SubscriptionId]$SUBSCRIPTION_ID"

- checkout: self

- task: AzureCLI@2
  displayName: 'Create resource group'
  inputs:
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: az group create --name ${{ parameters.ResourceGroupName }} --location ${{ parameters.AzureLocation }}

- task: PowerShell@2
  displayName: 'Generate version integer for database server name'
  inputs:
    targetType: 'inline'
    script: |
      [System.Environment]::SetEnvironmentVariable('Version','$(Build.BuildNumber)')
      $splitVersion = $env:Version -split "\."
      $stringVer = $splitVersion[-1]
      $intVer = [int]$stringVer
      Write-Host "##vso[task.setvariable variable=IntegerVersion]$intVer"

- task: AzureResourceGroupDeployment@2
  displayName: 'Create database resource in Azure'
  inputs:
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    resourceGroupName: $(ResourceGroupName)
    location: $(AzureLocation)
    csmFile: src/Database/DatabaseARM.json
    overrideParameters: -databaseserverName $(SubscriptionId)-dotnet8-tdd-$(IntegerVersion) -databaseLogin ${{ parameters.DatabaseUser }} -databaseLoginPassword ${{ parameters.DatabasePassword }} -skuCapacity 1 -databaseName ${{ parameters.DatabaseName }} -requestedServiceObjectiveName ${{ parameters.DatabasePerformanceLevel }}

- task: PowerShell@2
  displayName: 'Create database schema'
  inputs:
    targetType: filePath
    filePath: src/Database/scripts/UpdateAzurePipelineSql.ps1
    arguments: -DatabaseServer '$(SubscriptionId)-dotnet8-tdd-$(IntegerVersion).database.windows.net' -DatabaseName '${{ parameters.DatabaseNameTest }}' -DatabaseAction '${{ parameters.DatabaseAction }}' -DatabaseUser '${{ parameters.DatabaseUser }}' -DatabasePassword '${{ parameters.DatabasePassword }}'

- task: AzureCLI@2
  displayName: 'Get database connection string'
  inputs: 
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    scriptType: 'ps'
    scriptLocation: 'inlineScript' 
    inlineScript: |
      az config set extension.use_dynamic_install=yes_without_prompt
      $connstring = az sql db show-connection-string --server $(SubscriptionId)-dotnet8-tdd-$(IntegerVersion) --name ${{ parameters.DatabaseName }} --client ado.net
      $connstring = $connstring -replace '<username>', '${{ parameters.DatabaseUserTest }}' -replace '<password>', '${{ parameters.DatabasePasswordTest }}' -replace '"', ''
      Write-Host "##vso[task.setvariable variable=DbConnString]$connstring"

- task: AzureResourceGroupDeployment@2
  displayName: 'Create container app environment'
  inputs:
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    resourceGroupName: ${{ parameters.ResourceGroupName }}
    location: ${{ parameters.AzureLocation }}
    csmFile: src/Core/ContainerEnvironmentARM.json
    overrideParameters: -location ${{ parameters.AzureLocation }} -environment_name ${{ parameters.containerAppEnvironmentName }}

#- task: AzureResourceGroupDeployment@2
#  displayName: 'Create container app'
#  inputs:
#    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
#    resourceGroupName: ${{ parameters.ResourceGroupName }}
#    location: ${{ parameters.AzureLocation }}
#    csmFile: src/Core/ContainerARM.json
#    overrideParameters: -containerappName "${{ parameters.ContainerAppName }}" -location "${{ parameters.AzureLocation }}" -environment_name "${{  parameters.containerAppEnvironmentName }}" -container_image "${{ parameters.RegistryLoginServer }}/churchbulletin.ui:$(Build.BuildNumber)" -registry_password "${{ parameters.ContainerRegistryPassword }}"  -connection_string "$(DbConnString)" -http_port "${{ parameters.HttpPort }}" -registry_login_server "${{ parameters.RegistryLoginServer }}" -app_id "${{ parameters.AcrContainerAppId }}"

- task: AzureCLI@2
  displayName: 'Create Container App via CI'
  inputs: 
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    scriptType: 'ps'
    scriptLocation: 'inlineScript' 
    inlineScript: |
      ###############################################################################
      #The default az acr token create command prints the password to the screen and
      #as of November 2023 that remains totally uncontrollable behavior.  Rather than
      #live with it, we're going to generate that token without passwords and use
      #another command to generate the passwords for the acr login.
      ###############################################################################
      $DATE = Get-Date -format "yyyymmddHHMM"
      $TOKEN=$(az acr token create --name T$DATE --registry onionarchitecturemauiazuredotnet8.azurecr.io --repository churchbulletin.ui/* content/write content/read metadata/read metadata/write --no-passwords --output json) 
      az acr token credential generate -n T$DATE -r onionarchitecturemauiazuredotnet8 --password1 --expiration-in-days 30 --output json >> .\temp.json
      
      #cat temp.txt | jq '.passwords[0].value' >>acrp.txt
      
      $pwjson = get-content .\temp.json | Out-String | ConvertFrom-Json
      $TOKEN_FINAL = $pwjson.passwords.value

      
      ###############################################################################
      #Reading the password from the file we just wrote.  This, unfortunately, 
      #includes double quotes around the password string and az acr login Does Not
      #Like quotes around the -p field.  There has to be a better, more direct way
      #of reading the text into the variable than this, and that's on the TODO list.
      ###############################################################################
      #TOKEN_PWD=$(<acrp.txt)

      ###############################################################################
      #Now we've got an environment variable set for TOKEN_PWD and the value set from
      #the az acr token output parsed through jq.  Still has quotes and we can't have
      #that, so we're sedding the quote marks out.  Again, this is redirected to text
      #to avoid exposing the password in plain text, and because it simplifies the 
      #next variable we have to assign.
      ###############################################################################
      #wsl -e /bin/bash -c "sed -e 's/^"//' -e 's/"$//' <<<"$TOKEN_PWD" >> final.txt"

      ###############################################################################
      #Now that sed's pulled the quotes out from around the string, we assign to a 
      #new variable and that's what we'll pass into az acr login. We could (maybe 
      #should) recycle the $TOKEN_PWD variable and that's also on the list.  We're
      #not doing it here because the new variable has been tested and works, and
      #doesn't afford opportunities for variable assignment weirdness to flunk our
      #az acr login.
      ###############################################################################
      #TOKEN_FINAL=$(<final.txt)

      ###############################################################################
      #All that to get to this - the acr login that's weirdly difficult to achieve
      #with RBAC/ARM.  This gets us in, and affords us the access we'll need to build 
      #the container app from an image in the acr.
      ###############################################################################
      az acr login --name onionarchitecturemauiazuredotnet8 -u T$DATE  -p $TOKEN_FINAL
      az containerapp create --name ${{ parameters.ContainerAppName }} --resource-group ${{ parameters.ResourceGroupName }} --environment ${{ parameters.containerAppEnvironmentName }} --image ${{ parameters.RegistryLoginServer }}/churchbulletin.ui:$(Build.BuildNumber) --target-port ${{ parameters.HttpPort }} --ingress 'external' --query properties.configuration.ingress.fqdn


- task: AzureCLI@2
  displayName: 'Get the Fully Qualified Domain Name for the container app'
  inputs:
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      $fqdn = az containerapp show --name ${{ parameters.ContainerAppName }} --resource-group ${{ parameters.ResourceGroupName }} --query properties.configuration.ingress.fqdn
      $fqdn = $fqdn -replace '"', ''
      [System.Environment]::SetEnvironmentVariable("containerAppURL", $fqdn, "User")
      Write-Host "##vso[task.setvariable variable=fullyQualifiedDomainName]$fqdn"
      echo $fqdn

- task: AzureCLI@2
  displayName: 'Add revision to container app'
  inputs:
    azureSubscription: 'onion-architecture-maui-azure-dotnet-8-pure-azdo'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: az containerapp update --name ${{ parameters.ContainerAppName }} --resource-group ${{ parameters.ResourceGroupName }} --image ${{ parameters.ContainerImage }} --set-env-vars ConnectionStrings__SqlConnectionString="$(DbConnString)" HTTP_PORT=${{ parameters.HttpPort }}

- task: PowerShell@2
  displayName: 'Check version of deployed app'
  inputs:
    targetType: 'filePath'
    filePath: src/UI/Server/CheckVersion.ps1
    arguments: -server '$(fullyQualifiedDomainName)' -version '$(Build.BuildNumber)'

- task: PowerShell@2
  displayName: 'Perform healthcheck for server on container app'
  inputs:
    targetType: 'filePath'
    filePath: src/UI/Server/CallHealthCheckEndpoint.ps1
    arguments: -server '$(fullyQualifiedDomainName)'

- task: DownloadPackage@1
  displayName: 'Download Acceptance Test Package'
  inputs:
    packageType: 'nuget'
    feed: '${{ parameters.AzureFeedName }}'
    view: 'Local'
    definition: 'ChurchBulletin.AcceptanceTests'
    version: '$(Build.Buildnumber)'
    downloadPath: '$(System.DefaultWorkingDirectory)/tests'
    extract: true

- task: PowerShell@2
  displayName: 'Download Playwright'
  inputs:
    targetType: filePath
    filePath: ./tests/playwright.ps1
    arguments: 'install'

- task: VSTest@2
  displayName: 'VsTest - AcceptanceTests'
  inputs:
    testSelector: 'testAssemblies'
    testAssemblyVer2: |
      **\*AcceptanceTests.dll
      !**\*TestAdapter.dll
      !**\obj\**
      searchFolder: '$(System.DefaultWorkingDirectory)/tests'
    uiTests: true
    codeCoverageEnabled: true
    testRunTitle: 'Acceptance Tests'
    diagnosticsEnabled: True


